import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Goal, Category } from '../types';
import { goalApi } from '../api/goalApi';
import { useUserStore } from './userStore';

interface GoalState {
  goals: Goal[];
  currentGoal: Goal | null; // Kept for compatibility, but might be deprecated
  categories: Category[];
  setGoal: (goal: Goal) => Promise<void>; // Adds or updates goal
  updateGoal: (id: string, updates: Partial<Goal>) => Promise<void>;
  removeGoal: (id: string) => Promise<void>;
  addCategory: (name: string, icon: string) => void;
  removeCategory: (id: string) => void;
  syncWithBackend: () => Promise<void>;
}

const DEFAULT_CATEGORIES: Category[] = [
    { id: 'all', name: 'å…¨éƒ¨', icon: 'ğŸ“‹', isCustom: false },
    { id: 'reading', name: 'é˜…è¯»', icon: 'ğŸ“š', isCustom: false },
    { id: 'exercise', name: 'è¿åŠ¨', icon: 'ğŸƒ', isCustom: false },
    { id: 'sleep', name: 'ä½œæ¯', icon: 'ğŸ˜´', isCustom: false },
    { id: 'work', name: 'å·¥ä½œ', icon: 'ri-briefcase-line', isCustom: false },
    { id: 'outdoor', name: 'æˆ·å¤–', icon: 'ri-sun-line', isCustom: false },
    { id: 'fitness', name: 'å¥èº«', icon: 'ri-run-line', isCustom: false },
    { id: 'other', name: 'å…¶ä»–', icon: 'âœ¨', isCustom: false },
];

export const useGoalStore = create<GoalState>()(
  persist(
    (set, get) => ({
      goals: [],
      currentGoal: null,
      categories: DEFAULT_CATEGORIES,
      setGoal: async (goal) => {
          const user = useUserStore.getState().user;
          if (!user || !user.phone) {
               // Fallback for non-logged in users (if allowed) or throw
               // Assuming user must be logged in for "backend interaction"
               console.warn("User not logged in, goal saved locally only");
               // ... (keep local logic for guest if needed, but user asked for backend interaction)
          }

          const { goals } = get();
          
          // Determine if create or update
          // If goal has an ID that looks like 'goal-' + timestamp, it might be a new goal being created with a temp ID
          // But usually `setGoal` is called with a new object for creation.
          
          const isUpdate = goals.some(g => g.id === goal.id);
          
          if (isUpdate) {
               // Update
               // Optimistic Update
               const newGoals = goals.map(g => g.id === goal.id ? goal : g);
               set({ goals: newGoals, currentGoal: goal });
               
               if (user && user.phone) {
                   try {
                       await goalApi.updateGoal(goal.id, goal);
                   } catch (e: any) {
                       console.error("Failed to update goal on server", e);
                       // Revert? Or show error.
                       // For now, simple console error.
                   }
               }
          } else {
               // Create
               if (user && user.phone) {
                   try {
                       // Remove the temp ID if it was generated by the UI (e.g. 'goal-' + Date.now())
                       // Actually, the server accepts the ID if we send it.
                       // But to be "backend authoritative", we might want to let server decide or confirm.
                       // Let's send it as is, but wait for response.
                       
                       const savedGoal = await goalApi.createGoal({ ...goal, userId: user.id });
                       
                       if (savedGoal && savedGoal.id) {
                           set(state => ({
                               goals: [...state.goals, savedGoal],
                               currentGoal: savedGoal
                           }));
                       } else {
                           throw new Error("Server returned invalid goal");
                       }
                   } catch (e: any) {
                       console.error("Failed to create goal on server", e);
                       throw new Error(e.response?.data?.message || "åˆ›å»ºç›®æ ‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ");
                   }
               } else {
                   // Guest mode (if allowed)
                   set(state => ({
                       goals: [...state.goals, goal],
                       currentGoal: goal
                   }));
               }
          }
      },
      updateGoal: async (id, updates) => {
        const { goals } = get();
        const goalIndex = goals.findIndex(g => g.id === id);
        
        if (goalIndex >= 0) {
            const goal = goals[goalIndex];
            const updated = { ...goal, ...updates };
            
            const newGoals = [...goals];
            newGoals[goalIndex] = updated;
            
            set({ goals: newGoals, currentGoal: updated });
            
            const user = useUserStore.getState().user;
            if (user && user.phone) {
                try {
                    await goalApi.updateGoal(id, updates);
                } catch (e) {
                    console.error("Failed to update goal on server", e);
                }
            }
        }
      },
      removeGoal: async (id) => {
          const { goals } = get();
          const newGoals = goals.filter(g => g.id !== id);
          set({ goals: newGoals, currentGoal: newGoals.length > 0 ? newGoals[0] : null });
          
          const user = useUserStore.getState().user;
          if (user && user.phone) {
              try {
                  await goalApi.deleteGoal(id);
              } catch (e) {
                  console.error("Failed to delete goal on server", e);
              }
          }
      },
      addCategory: (name, icon) => 
        set((state) => ({
            categories: [
                ...state.categories, 
                { id: 'cat-' + Date.now(), name, icon, isCustom: true }
            ]
        })),
      removeCategory: (id) =>
        set((state) => ({
            categories: state.categories.filter(c => c.id !== id || !c.isCustom)
        })),
      syncWithBackend: async () => {
          const user = useUserStore.getState().user;
          if (user && user.phone) {
              try {
                  const goals = await goalApi.getGoals(user.id);
                  if (goals) {
                      set({ goals: goals, currentGoal: goals.length > 0 ? goals[0] : null });
                  }
              } catch (e) {
                  console.error("Failed to fetch goals", e);
              }
          }
      }
    }),
    {
      name: 'goal-storage',
      version: 2,
      migrate: (state) => {
        if (!state) return state;
        const categories: Category[] = (state as any).categories || [];
        let updated = categories.filter(c => c.id !== 'water');
        const ensure = (id: string, name: string, icon: string) => {
          if (!updated.some(c => c.id === id)) {
            updated.push({ id, name, icon, isCustom: false });
          }
        };
        ensure('work', 'å·¥ä½œ', 'ri-briefcase-line');
        ensure('outdoor', 'æˆ·å¤–', 'ri-sun-line');
        ensure('fitness', 'å¥èº«', 'ri-run-line');
        (state as any).categories = updated;
        return state;
      },
      partialize: (state) => ({ 
        goals: state.goals,
        currentGoal: state.currentGoal,
        categories: state.categories 
      }),
    }
  )
);

export const GOAL_TEMPLATES: Omit<Goal, 'id'>[] = [
  { name: 'è¯»10é¡µä¹¦', category: 'reading', duration: 20, frequency: 'daily' },
  { name: 'åš20ä¸ªæ·±è¹²', category: 'exercise', duration: 5, frequency: 'daily' },
  { name: '23ç‚¹å‰ç¡è§‰', category: 'sleep', duration: 0, frequency: 'daily' },
];
